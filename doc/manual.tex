% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}



\usepackage[pdftex]{graphicx}

%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{\textsf{FSR}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=\textsf{FSR}}
\markright{\scriptsize \mbox{}\hfill \textsf{FSR} \hfill\mbox{}}
{\Huge \textbf{...\mbox{}}}\\
\vfill

{\Huge Version 1.0.4\mbox{}}\\[1cm]
{17 January 2017\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{Nusa Zidaric   \mbox{}}}\\
\hypersetup{pdfauthor=Nusa Zidaric   }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Nusa Zidaric   }  Email: \href{mailto://email} {\texttt{email}}\\
  Homepage: \href{http://} {\texttt{http://}}}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 \index{FSR package@\textsf{FSR} package} The \textsf{GAP} package \textsf{FSR} ... \mbox{}}\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
 {\copyright} 2017-2017 by Nusa Zidaric, Mark Aagaard, Guang Gong

 \textsf{FSR} is free software; you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version. For
details, see the FSF's own site \href{http://www.gnu.org/licenses/gpl.html} {\texttt{http://www.gnu.org/licenses/gpl.html}}. 

 If you obtained \textsf{FSR}, we would be grateful for a short notification sent to one of the authors. 

 If you publish a result which was partially obtained with the usage of \textsf{FSR}, please cite it in the following form: 

 N. Zidaric. ... \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 3 ]}
 ... \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 4 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Preface}}\label{Preface}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X874E1D45845007FE}{}
{
  The \textsf{GAP} package \textsf{FSR} implements Feedback Shift Registers }

 
\chapter{\textcolor{Chapter }{Output formatting functions and TEX drawing functions}}\label{Outputs}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7F7E555B782ECF45}{}
{
  
\section{\textcolor{Chapter }{Output formatting functions}}\label{Formatting}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7EB095598359B4B3}{}
{
  \index{outputs} There are two types of functions: ones that return the input in a human
friendly version (as strings or list of strings), and ones that write the
human friendly version of the input into a file (txt or tex) 

\subsection{\textcolor{Chapter }{ IntFFExt}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X7C848712781083D5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ IntFFExt({\mdseries\slshape [B, ]ffe})\index{ IntFFExt@\texttt{ IntFFExt}}
\label{ IntFFExt}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ IntVecFFExt({\mdseries\slshape [B, ]vec})\index{ IntVecFFExt@\texttt{ IntVecFFExt}}
\label{ IntVecFFExt}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ IntMatFFExt({\mdseries\slshape [B, ]M})\index{ IntMatFFExt@\texttt{ IntMatFFExt}}
\label{ IntMatFFExt}
}\hfill{\scriptsize (method)}}\\


 \texttt{IntFFExt} takes the \mbox{\texttt{\mdseries\slshape ffe}} and writes it as an integer of the prime field if \mbox{\texttt{\mdseries\slshape ffe}} is an element of the prime field (same as Int(ffe)), or writes it as a vector
of integers from the prime subfield if \mbox{\texttt{\mdseries\slshape ffe}} is an element of an extension field, using the given basis \mbox{\texttt{\mdseries\slshape B}} or canonical basis representation of \mbox{\texttt{\mdseries\slshape ffe}} if no basis is provided. 

 \texttt{IntVecFFExt} takes the vector \mbox{\texttt{\mdseries\slshape vec}} of FFEs and writes it in a human friendly version: as a vector of integers
from the prime field if all components of \mbox{\texttt{\mdseries\slshape vec}} belong to a prime field, or as a vector of vectors of integers from the prime
subfield, if the components belong to an extension field, using the given
basis \mbox{\texttt{\mdseries\slshape B}} or canonical basis representation of \mbox{\texttt{\mdseries\slshape ffe}}, if no basis is provided. (note: all components are treated as elements of
the largest field). 

 \texttt{IntMatFFExt} takes a matrix \mbox{\texttt{\mdseries\slshape M}} and returns its human friendly version: a matrix of vectors of integers from
the prime field if all components of \mbox{\texttt{\mdseries\slshape M}} belong to a prime field, or a vector of row vectors, whose elements are
vectors of integers from the prime subfield, if the components belong to an
extension field, using the given basis \mbox{\texttt{\mdseries\slshape B}} or canonical basis representation of components of \mbox{\texttt{\mdseries\slshape M}}. 

 NOTE: the non-basis versions return a representation in the smallest field
that contains the element. for representation in a specific field, use the
basis version with desired basis. }

 

\subsection{\textcolor{Chapter }{VecToString}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X78387B8B7940F96C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{VecToString({\mdseries\slshape [B, ]vec})\index{VecToString@\texttt{VecToString}}
\label{VecToString}
}\hfill{\scriptsize (method)}}\\


 Writes a FFE verctor or matrix as string or list of strings using the given
basis \mbox{\texttt{\mdseries\slshape B}} or canonical basis representation of \mbox{\texttt{\mdseries\slshape ffe}} if no basis is provided. This mathod calls methods \texttt{IntFFExt}, \texttt{IntVecFFExt} and \texttt{IntMatFFExt} from section LINK. The list of strings is more practically useful: we wish to
have the components as srings, therefore the human friendly version of a
matrix is not an actual string. 

 NOTE: the non-basis versions return a representation in the cononical basis of
the smallest field that contains the element. For representation in a specific
field, use the basis version with desired basis. }

 

\subsection{\textcolor{Chapter }{WriteVector (for a FFE and given basis)}}
\logpage{[ 2, 1, 3 ]}\nobreak
\hyperdef{L}{X7F4DA7FE7C10E782}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteVector({\mdseries\slshape output, B, vec})\index{WriteVector@\texttt{WriteVector}!for a FFE and given basis}
\label{WriteVector:for a FFE and given basis}
}\hfill{\scriptsize (function)}}\\


 Writes the human friendly version of vector \mbox{\texttt{\mdseries\slshape vec}} represented in basis \mbox{\texttt{\mdseries\slshape B}}, to the output file \mbox{\texttt{\mdseries\slshape output}}. Also works if \mbox{\texttt{\mdseries\slshape vec}} is an integer or FFE. 

 NOTE: the basis MUST be provided. 

 Also works for writing matrices, but writes them as a row vector, not as a
rectangle. }

 

\subsection{\textcolor{Chapter }{WriteMatrix (for a matrix of FFE and given basis)}}
\logpage{[ 2, 1, 4 ]}\nobreak
\hyperdef{L}{X7FB7643986FE0503}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteMatrix({\mdseries\slshape output, B, M})\index{WriteMatrix@\texttt{WriteMatrix}!for a matrix of FFE and given basis}
\label{WriteMatrix:for a matrix of FFE and given basis}
}\hfill{\scriptsize (function)}}\\


 Writes the human friendly version of matrix \mbox{\texttt{\mdseries\slshape M}} represented in basis \mbox{\texttt{\mdseries\slshape B}} to the output file \mbox{\texttt{\mdseries\slshape output}} nicely formatted (rectangular, each row in a new line). 

 NOTE: the basis MUST be provided. }

 

\subsection{\textcolor{Chapter }{WriteMatrixTEX}}
\logpage{[ 2, 1, 5 ]}\nobreak
\hyperdef{L}{X7C88DF8385B5C384}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteMatrixTEX({\mdseries\slshape output, M})\index{WriteMatrixTEX@\texttt{WriteMatrixTEX}}
\label{WriteMatrixTEX}
}\hfill{\scriptsize (function)}}\\


 Writes the TEX code for matrix \mbox{\texttt{\mdseries\slshape M}} over a prime field to the output file \mbox{\texttt{\mdseries\slshape output}}. 

 NOTE: Only works for matrices over a prime field !!! }

 }

 
\section{\textcolor{Chapter }{TEX drawing functions}}\label{Drawing}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X84E367F97DBA31D2}{}
{
  }

 }

 
\chapter{\textcolor{Chapter }{FSR (Feedback Shift Register)}}\label{FSR}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7D2B014884E6D3D8}{}
{
  
\section{\textcolor{Chapter }{Common functionality}}\label{fsrcommon}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X7D5E0FF97CA51E2E}{}
{
  \index{fsr} We define an object \textsf{FSR} (Feedback Shift Register), which can come in two flavours: with linear
feedback \texttt{LFSR} (\ref{LFSR}) and nonlinear feedback \texttt{NLFSR} (\ref{NLFSR}). Because of many similarities between the two, the basic common functionality
can be found here, while specialized functions (such as \texttt{LFSR} and \texttt{NLFSR} object creation) in corresponding sections. 

\subsection{\textcolor{Chapter }{IsFSR}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X867B95117FAEC3E6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFSR\index{IsFSR@\texttt{IsFSR}}
\label{IsFSR}
}\hfill{\scriptsize (filter)}}\\


 This is the category of \texttt{FSR} objects. Objects in this category are created using functions \texttt{LFSR} (\ref{LFSR}) or \texttt{NLFSR} (\ref{NLFSR}). }

 

\subsection{\textcolor{Chapter }{FieldPoly}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X828F246B82428CC9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FieldPoly({\mdseries\slshape fsr})\index{FieldPoly@\texttt{FieldPoly}}
\label{FieldPoly}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnderlyingField({\mdseries\slshape fsr})\index{UnderlyingField@\texttt{UnderlyingField}}
\label{UnderlyingField}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FeedbackVec({\mdseries\slshape fsr})\index{FeedbackVec@\texttt{FeedbackVec}}
\label{FeedbackVec}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OutputTap({\mdseries\slshape fsr})\index{OutputTap@\texttt{OutputTap}}
\label{OutputTap}
}\hfill{\scriptsize (attribute)}}\\


 \texttt{FieldPoly} of the \mbox{\texttt{\mdseries\slshape fsr}} stores the irreducible polynomial used to construct the extension field or 1
in case of a prime field.

 \texttt{UnderlyingField} of the \mbox{\texttt{\mdseries\slshape fsr}} is the finite field over which the \mbox{\texttt{\mdseries\slshape fsr}} is defined (all indeterminates and constants are from this field). 

 NOTE: it may seem redundant to sore both \texttt{FieldPoly} and \texttt{UnderlyingField}, however, they are used by other functions in the package. 

 \texttt{FeedbackVec} of the \mbox{\texttt{\mdseries\slshape fsr}} stores the coefficients of the \texttt{CharPoly} without its leading term in case of \texttt{LFSR}, and coefficients of the nonzero monomials present in the multivariate
function defining the feedback in case of \texttt{NLFSR}.

 \texttt{OutputTap} holds the output tap position(s): the sequence elements are taken from the
stage(s) listed in \texttt{OutputTap}. }

 

\subsection{\textcolor{Chapter }{Length}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X780769238600AFD1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Length({\mdseries\slshape fsr})\index{Length@\texttt{Length}}
\label{Length}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InternalStateSize({\mdseries\slshape fsr})\index{InternalStateSize@\texttt{InternalStateSize}}
\label{InternalStateSize}
}\hfill{\scriptsize (attribute)}}\\


 \texttt{Length} of the \mbox{\texttt{\mdseries\slshape fsr}} is the number of its stages.

 \texttt{InternalStateSize} of the \mbox{\texttt{\mdseries\slshape fsr}} is size in bits needed to store the state $length \cdot width$, where $ width = DegreeOverPrimeField(UnderlyingField(\mbox{\texttt{\mdseries\slshape fsr}}))$ }

 

\subsection{\textcolor{Chapter }{LoadFSR}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X7F800DCF810E2532}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LoadFSR({\mdseries\slshape fsr, ist})\index{LoadFSR@\texttt{LoadFSR}}
\label{LoadFSR}
}\hfill{\scriptsize (method)}}\\


 Loading the \mbox{\texttt{\mdseries\slshape fsr}} with the initial state \mbox{\texttt{\mdseries\slshape ist}}, which is a \mbox{\texttt{\mdseries\slshape FFE}} vector of same length as \mbox{\texttt{\mdseries\slshape fsr}} and with elements from its underlying finite field. If either of those two
requirements is violated, loading fails and error message appears. At the time
of loading the initial sequence elements (ie zeroth elements) are obtained and \texttt{numsteps} is set to 0.

 }

 

\subsection{\textcolor{Chapter }{StepFSR}}
\logpage{[ 3, 1, 5 ]}\nobreak
\hyperdef{L}{X82A7CA487ECAEFD5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{StepFSR({\mdseries\slshape fsr[, elm]})\index{StepFSR@\texttt{StepFSR}}
\label{StepFSR}
}\hfill{\scriptsize (method)}}\\


 Perform one step the \mbox{\texttt{\mdseries\slshape fsr}}, ie. compute the new \texttt{state} and update the \texttt{numsteps}, then output the elements denoted by \texttt{OutputTap}. If the optional parameter \mbox{\texttt{\mdseries\slshape elm}} is used then the new element is computed as a sum of computed feedback and \mbox{\texttt{\mdseries\slshape elm}}. Elemen \mbox{\texttt{\mdseries\slshape elm}} must be an element of the underlying finite field. 

 As this is a way to destroy the linearity of an \texttt{LFSR}, we refer to \texttt{StepFSR} with the optiomal nonzero \mbox{\texttt{\mdseries\slshape elm}} as \texttt{nonlinear step}. Similarly, the \texttt{NLFSR} can also have an extra element added to the (already nonlinear) feedback.

 Returns an error if the \mbox{\texttt{\mdseries\slshape fsr}} is not loaded!

 }

 

\subsection{\textcolor{Chapter }{RunFSR}}
\logpage{[ 3, 1, 6 ]}\nobreak
\hyperdef{L}{X86AAB63D8781648A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RunFSR({\mdseries\slshape fsr[, B, ist, num, pr]})\index{RunFSR@\texttt{RunFSR}}
\label{RunFSR}
}\hfill{\scriptsize (method)}}\\
\textbf{\indent Returns:\ }
 A sequence of elements generated by \texttt{FSR}. 



 The \mbox{\texttt{\mdseries\slshape fsr}} will be run for a certain (\mbox{\texttt{\mdseries\slshape num}} or \mbox{\texttt{\mdseries\slshape threshold}}) number of steps: there is a threshold value, currently set to
2\texttt{\symbol{94}}\emph{Length(\mbox{\texttt{\mdseries\slshape fsr}})} + \emph{Length(\mbox{\texttt{\mdseries\slshape fsr}})}, which is used by all versions without explicit \mbox{\texttt{\mdseries\slshape num}} and enforced when \mbox{\texttt{\mdseries\slshape num}} exceeds \mbox{\texttt{\mdseries\slshape threshold}}. There is an optional printing switch \mbox{\texttt{\mdseries\slshape pr}}, with default set to \emph{false}; if \emph{true} then the state and the output sequence element(s) are printed in \textsf{GAP} shell on every step of the \mbox{\texttt{\mdseries\slshape fsr}} (we call this output for \texttt{RunFSR}), and the given basis \mbox{\texttt{\mdseries\slshape B}} is used for representation of elements. Note that having both a pint switch
and a basis is redundant, however, the additional boolean helps the method
selection to distinguish between calls with basis and calls with both initial
state \mbox{\texttt{\mdseries\slshape ist}} and the cvector of FFE elements \mbox{\texttt{\mdseries\slshape elmvec}} to be used for nonlinear steps (because all three vectors return true for
IsFFECollection). 
\begin{itemize}
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr[, B, num, pr] }})} - run \mbox{\texttt{\mdseries\slshape fsr}} for \mbox{\texttt{\mdseries\slshape num}}/\mbox{\texttt{\mdseries\slshape threshold}} steps with/without output
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr, [B,] ist[, num, pr] }})} - load \mbox{\texttt{\mdseries\slshape fsr}} with \mbox{\texttt{\mdseries\slshape ist}}, then run \mbox{\texttt{\mdseries\slshape fsr}} for \mbox{\texttt{\mdseries\slshape num}}/\mbox{\texttt{\mdseries\slshape threshold}} steps with/without output (ie. \emph{linear} version)
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr, [B,] elm[, num, pr] }})} - run \mbox{\texttt{\mdseries\slshape fsr}} for \mbox{\texttt{\mdseries\slshape num}}/\mbox{\texttt{\mdseries\slshape threshold}} steps, whereby the SAME element \mbox{\texttt{\mdseries\slshape elm}} is added to the feedback at each step, with/without output (ie. \emph{non-linear} version)
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr, [B,] ist, elmvec[, pr] }})} - load \mbox{\texttt{\mdseries\slshape fsr}} with \mbox{\texttt{\mdseries\slshape ist}}, then run \mbox{\texttt{\mdseries\slshape fsr}} for \emph{Length(\mbox{\texttt{\mdseries\slshape elmvec}})} steps, whereby one element of \mbox{\texttt{\mdseries\slshape elmvec}} is added to the feedback at each step (starting with \mbox{\texttt{\mdseries\slshape elmvec[1]}}), with/without output (ie. \emph{non-linear} version). NOTE: the sequence returned has length \emph{Length(elmvec)+1}, because the zeroth sequence element is returned at the time of loading the \texttt{FSR}.
\end{itemize}
 For the load and run versions, element seq$_0$ is a part of the output sequence, hence the output sequence has the length \mbox{\texttt{\mdseries\slshape num+1}}/\mbox{\texttt{\mdseries\slshape threshold+1}}/\mbox{\texttt{\mdseries\slshape Length(elmvec)+1}}. 

 For versions without the loading of \mbox{\texttt{\mdseries\slshape ist}}, calling \texttt{RunFSR} returns an error if the \mbox{\texttt{\mdseries\slshape fsr}} is not loaded!

 The ouput of \texttt{RunFSR} is: 
\begin{itemize}
\item  sequence of \mbox{\texttt{\mdseries\slshape FFE}}s : seq$_0$, seq$_1$, seq$_2$, $\dots ,$ for \emph{Length}(\emph{OutputTap})=1
\item  sequence of vectors, each of them with $t$ \mbox{\texttt{\mdseries\slshape FFE}}s : seq$_0$, seq$_1$, seq$_2$, $\dots ,$ where seq$_i=($ seq$_{i1}$, $\dots ,$ seq$_{it}$) for \emph{Length}(\emph{OutputTap})=t
\end{itemize}
 Example of \texttt{RunFSR} called for an lfsr \emph{test} over $F_{2^4}$, with initial state \emph{ist}, print switch \emph{true} for basis \emph{B}, with run length 5: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@K := GF(2);; x := X(K, "x");;|
  !gapprompt@gap>| !gapinput@f := x^4 + x^3 + 1;; F := FieldExtension(K, f);; B := Basis(F);;|
  !gapprompt@gap>| !gapinput@y := X(F, "y");; l := y^4+ y+ Z(2^4);;|
  !gapprompt@gap>| !gapinput@test := LFSR(K, f, l);;|
  < empty LFSR given by CharPoly = y^4+y+Z(2^4)>
  !gapprompt@gap>| !gapinput@ist :=[0*Z(2), Z(2^4), Z(2^4)^5, Z(2)^0 ];;|
  !gapprompt@gap>| !gapinput@RunFSR(test, B, ist, 5, true);             |
  using basis B := [ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]	
  elm 		[ 3,......,0 ]  with taps  [ 0 ]
  		[ [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 1 ], [ 1, 0, 0, 0 ] ]		[ 1, 0, 0, 0 ]
  		[ [ 1, 0, 1, 1 ], [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 1 ] ]		[ 1, 1, 0, 1 ]
  		[ [ 0, 1, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ] ]		[ 0, 1, 1, 0 ]
  		[ [ 1, 0, 1, 1 ], [ 0, 1, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 0, 0, 0 ] ]		[ 0, 0, 0, 0 ]
  		[ [ 1, 0, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 1, 1, 1 ], [ 1, 0, 1, 1 ] ]		[ 1, 0, 1, 1 ]
  		[ [ 1, 1, 0, 1 ], [ 1, 0, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 1, 1, 1 ] ]		[ 0, 1, 1, 1 ]
  [ Z(2)^0, Z(2^2), Z(2^4), 0*Z(2), Z(2^4)^2, Z(2^4)^11 ]
  
\end{Verbatim}
 Example of \texttt{RunFSR} called for an lfsr \emph{test} over $F_{2^4}$, with initial state \emph{ist}, print switch \emph{true} for basis \emph{B}, with 5 nonlinear inputs : 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@elmvec := [Z(2^4)^2, Z(2^4)^2, Z(2^2), Z(2^4)^7, Z(2^4)^6];;                                |
  !gapprompt@gap>| !gapinput@RunFSR(test, B, ist, elmvec, true);                         |
  elm 		[ 3,......,0 ]  with taps  [ 0 ]
   		[ [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ]		[ 0, 0, 0, 0 ]
  [ 1, 0, 1, 1 ]		[ [ 1, 0, 1, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ]		[ 0, 0, 0, 0 ]
  [ 1, 0, 1, 1 ]		[ [ 1, 0, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ]		[ 0, 0, 0, 0 ]
  [ 1, 1, 0, 1 ]		[ [ 1, 1, 0, 1 ], [ 1, 0, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 0, 0, 0 ] ]		[ 0, 0, 0, 0 ]
  [ 0, 1, 0, 0 ]		[ [ 1, 1, 1, 1 ], [ 1, 1, 0, 1 ], [ 1, 0, 1, 1 ], [ 1, 0, 1, 1 ] ]		[ 1, 0, 1, 1 ]
  [ 0, 0, 0, 1 ]		[ [ 0, 0, 0, 0 ], [ 1, 1, 1, 1 ], [ 1, 1, 0, 1 ], [ 1, 0, 1, 1 ] ]		[ 1, 0, 1, 1 ]
  [ Z(2^4)^2, 0*Z(2), 0*Z(2), 0*Z(2), Z(2^4)^2, Z(2^4)^2 ]
  
\end{Verbatim}
 In both examples above the there is a column \emph{elm}, which is in first case empty, because we are not adding nonlinear inputs to
the feedback, while in the second example, this column shows the element being
added at each step (empty in first row - the loading step). Also note that the
two examples above use the call \texttt{LoadFSR}, which adds the elm seq${{_0}}$ to the sequaence, so both sequences above are of length \mbox{\texttt{\mdseries\slshape num+1}}/\mbox{\texttt{\mdseries\slshape Length(elmvec)+1}}, ie 6. The last row in both examples is the actual sequence obtained from
this run, and is kept in Zechs logarithm representation. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@RunFSR(test,  ist); Length(last);|
  [ Z(2)^0, Z(2^2), Z(2^4), 0*Z(2), Z(2^4)^2, Z(2^4)^11, Z(2^4)^2, Z(2^4)^2, Z(2^2), Z(2^4)^7, Z(2^4)^6, Z(2^4)^11, 
    Z(2^2)^2, Z(2^4)^14, Z(2^4)^8, Z(2^4)^3, Z(2^2)^2, Z(2^4)^2, Z(2^4), Z(2^4)^2, Z(2^4)^9 ]
  21
  
\end{Verbatim}
 Last example above shows a sequence of length 21, ie \mbox{\texttt{\mdseries\slshape threshold+1}}, getting first sequence element from LoadFSR followed by \mbox{\texttt{\mdseries\slshape threshold}} iterations of StepFSR. }

 }

 
\section{\textcolor{Chapter }{LFSR specific funcionality}}\label{lfsr}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X7A98C0FE855337A7}{}
{
  

\subsection{\textcolor{Chapter }{LFSR}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X8099A9DC86E0B078}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LFSR({\mdseries\slshape F, charpol[, tap]})\index{LFSR@\texttt{LFSR}}
\label{LFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LFSR({\mdseries\slshape K, fieldpol, charpol[, tap]})\index{LFSR@\texttt{LFSR}}
\label{LFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LFSR({\mdseries\slshape F, charpol[, tap]})\index{LFSR@\texttt{LFSR}}
\label{LFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LFSR({\mdseries\slshape p, m, n[, tap]})\index{LFSR@\texttt{LFSR}}
\label{LFSR}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 An empty \texttt{LFSR} with components \texttt{init}, \texttt{state} and \texttt{numsteps} 



 Different ways to create an \texttt{LFSR} oblject, main difference is in creation of the underlying finite field. 

 Inputs: 
\begin{itemize}
\item  \mbox{\texttt{\mdseries\slshape F}} - the underlying finite field (either an extension field or a prime field)
\item  \mbox{\texttt{\mdseries\slshape charpol}} - \texttt{LFSR} dfining polynomial 
\item  \mbox{\texttt{\mdseries\slshape fieldpol}} - defifning polynomial of the extension field (must be irreducible)
\item  \mbox{\texttt{\mdseries\slshape p}} - characteeristic 
\item  \mbox{\texttt{\mdseries\slshape m}} - degree of extension (degree of \mbox{\texttt{\mdseries\slshape fieldpol}}) 
\item  \mbox{\texttt{\mdseries\slshape n}} - length of \texttt{LFSR} (degree of \mbox{\texttt{\mdseries\slshape charpoly}})
\item  \mbox{\texttt{\mdseries\slshape tap}} - optional parameter: the output tap (must be a positive integer or a list of
positive integers) and will be changed to the default S{\textunderscore}0 if
the specified integer is out of \texttt{LFSR} range.
\end{itemize}
 Compoents: 
\begin{itemize}
\item  \texttt{init} - \mbox{\texttt{\mdseries\slshape FFE}} vector of length n=deg(charpol), storing the initial state of the \texttt{LFSR}, with indeces from n-1, ..., 0
\item  \texttt{state} - \mbox{\texttt{\mdseries\slshape FFE}} vector of length n=deg(charpol), storing the current state of the \texttt{LFSR}, with indeces from n-1, ..., 0
\item  \texttt{numsteps} - the number of steps performed thus far (initialized to -1 when created, set
to 0 when loaded using \texttt{LoadFSR} (\ref{LoadFSR}) and incremented by 1 with each step (using \texttt{StepFSR} (\ref{StepFSR}))) 
\end{itemize}
 Attributes \texttt{FieldPoly} (\ref{FieldPoly}), \texttt{UnderlyingFied} (\ref{UnderlyingFied}), \texttt{CharPoly}, \texttt{FeedbackVec} (\ref{FeedbackVec}), \texttt{Length} (\ref{Length}) and \texttt{OutputTap} (\ref{OutputTap}) and the property \texttt{IsLinearFeedback} are set during the construction of an\texttt{LFSR}. 

 If there is something wrong with the arguments (e.g. attempting to create an
extension field using a reducible poynomial), an error message appears and the
function returns \texttt{fail}.

 Example below shows how to create an empty \texttt{LFSR} over $F_{2^4}$ created as extension of $F_2$, called \emph{test}: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@K := GF(2);; x := X(K, "x");;|
  !gapprompt@gap>| !gapinput@f := x^4 + x^3 + 1;; F := FieldExtension(K, f);; |
  !gapprompt@gap>| !gapinput@y := X(F, "y");; l := y^4+ y+ Z(2^4);;|
  !gapprompt@gap>| !gapinput@test := LFSR(K, f, l);|
  < empty LFSR given by CharPoly = y^4+y+Z(2^4)>
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsLinearFeedback}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X80DF9A3D7B1E3E92}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLinearFeedback({\mdseries\slshape lfsr})\index{IsLinearFeedback@\texttt{IsLinearFeedback}}
\label{IsLinearFeedback}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLFSR({\mdseries\slshape lfsr})\index{IsLFSR@\texttt{IsLFSR}}
\label{IsLFSR}
}\hfill{\scriptsize (filter)}}\\


 If we were to represent the \mbox{\texttt{\mdseries\slshape lsfr}} with a multivariate polynomial, DegreeOfPolynomial would return 1 - the
feedback polynomial is linear and \texttt{IsLinearFeedback} is set to \emph{true}. (ie. only linear terms are present: monomials with only one variable )

 Filter \texttt{IsLFSR} is defined as and-filter of \texttt{IsFSR} and \texttt{IsLinearFeedback}. }

 

\subsection{\textcolor{Chapter }{CharPoly}}
\logpage{[ 3, 2, 3 ]}\nobreak
\hyperdef{L}{X7D4D9DCC7B4BE3ED}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CharPoly({\mdseries\slshape lfsr})\index{CharPoly@\texttt{CharPoly}}
\label{CharPoly}
}\hfill{\scriptsize (attribute)}}\\


 Attribute holding the characteristic polynomial (the feedback polynomial). }

 

\subsection{\textcolor{Chapter }{IsPeriodic}}
\logpage{[ 3, 2, 4 ]}\nobreak
\hyperdef{L}{X81AC5D2D832C346A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPeriodic({\mdseries\slshape lfsr})\index{IsPeriodic@\texttt{IsPeriodic}}
\label{IsPeriodic}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsUltPeriodic({\mdseries\slshape lfsr})\index{IsUltPeriodic@\texttt{IsUltPeriodic}}
\label{IsUltPeriodic}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsMaxSeqLFSR({\mdseries\slshape lfsr})\index{IsMaxSeqLFSR@\texttt{IsMaxSeqLFSR}}
\label{IsMaxSeqLFSR}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Period({\mdseries\slshape lfsr})\index{Period@\texttt{Period}}
\label{Period}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PeriodIrreducible({\mdseries\slshape lfsr})\index{PeriodIrreducible@\texttt{PeriodIrreducible}}
\label{PeriodIrreducible}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PeriodReducible({\mdseries\slshape lfsr})\index{PeriodReducible@\texttt{PeriodReducible}}
\label{PeriodReducible}
}\hfill{\scriptsize (method)}}\\


 Properties, attributes and methods concerning the periodicity of the output
sequence(s), generated by the \mbox{\texttt{\mdseries\slshape lsfr}}. 

 Properties: 
\begin{itemize}
\item  \texttt{IsPeriodic}: true if constant term of \texttt{CharPoly} != 0 (8.11 lidl, niederreiter) 
\item  \texttt{IsUltPeriodic}: true if \texttt{IsLFSR} is true (8.7 lidl, niederreiter) 
\item  \texttt{IsMaxSeqLFSR}: true if \texttt{CharPoly} is primitive (ref???) 
\end{itemize}
 Attributes: 
\begin{itemize}
\item  \texttt{Period}: holds the period of the UNKNOWNEntity(LFSR) 
\end{itemize}
 Methods to compute the period: 
\begin{itemize}
\item  \texttt{PeriodIrreducible}: 
\item  \texttt{PeriodReducible}: 
\end{itemize}
 }

 

\subsection{\textcolor{Chapter }{ViewObj}}
\logpage{[ 3, 2, 5 ]}\nobreak
\hyperdef{L}{X815BF22186FD43C9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ViewObj({\mdseries\slshape lfsr})\index{ViewObj@\texttt{ViewObj}}
\label{ViewObj}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrintObj({\mdseries\slshape lfsr[, B]})\index{PrintObj@\texttt{PrintObj}}
\label{PrintObj}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrintAll({\mdseries\slshape lfsr[, B]})\index{PrintAll@\texttt{PrintAll}}
\label{PrintAll}
}\hfill{\scriptsize (method)}}\\


 Different detail on the \mbox{\texttt{\mdseries\slshape lfsr}} created by \texttt{LFSR} (\ref{LFSR}): 
\begin{itemize}
\item  \texttt{Display/View}: show the \texttt{CharPoly} and wheter or not the \mbox{\texttt{\mdseries\slshape lsfr}} is empty
\item  \texttt{Print}: same as \texttt{Display/View} if \mbox{\texttt{\mdseries\slshape lsfr}} is empty, otherwise it also shows the values of the three components \texttt{init}, \texttt{state} and \texttt{numsteps}
\item  \texttt{PrintAll}: same as \texttt{Print} if \mbox{\texttt{\mdseries\slshape lsfr}} is empty, otherwise it also shows the values of the three components \texttt{init}, \texttt{state} and \texttt{numsteps} with additional information about the underlying field and the tap positions. 
\end{itemize}
 Both \texttt{Print} and \texttt{PrintAll} can be used with optional parameter basis \mbox{\texttt{\mdseries\slshape B}} for desiered output format. Below are examples of output 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@K := GF(2);; x := X(K, "x");;|
  !gapprompt@gap>| !gapinput@f := x^4 + x^3 + 1;; F := FieldExtension(K, f);; B := Basis(F);;|
  !gapprompt@gap>| !gapinput@y := X(F, "y");; l := y^4+ y+ Z(2^4);;|
  !gapprompt@gap>| !gapinput@test := LFSR(K, f, l);;|
  !gapprompt@gap>| !gapinput@Print(test);           |
  Empty LFSR given by CharPoly = y^4+y+Z(2^4)
  !gapprompt@gap>| !gapinput@LoadFSR(test, ist);|
  Z(2)^0
  !gapprompt@gap>| !gapinput@Print(test);           |
  LFSR given by CharPoly = y^4+y+Z(2^4)
  
  with initial state =[ 0*Z(2), Z(2^4), Z(2^2), Z(2)^0 ]
  with current state =[ 0*Z(2), Z(2^4), Z(2^2), Z(2)^0 ]
  after  0 steps
  !gapprompt@gap>| !gapinput@RunFSR(test,5);|
  [ Z(2^2), Z(2^4), 0*Z(2), Z(2^4)^2, Z(2^4)^11 ]
  !gapprompt@gap>| !gapinput@Print(test);   |
  LFSR given by CharPoly = y^4+y+Z(2^4)
  with initial state =[ 0*Z(2), Z(2^4), Z(2^2), Z(2)^0 ]
  with current state =[ Z(2^2), Z(2^4)^2, Z(2^4)^2, Z(2^4)^11 ]
  after  5 steps
  !gapprompt@gap>| !gapinput@PrintAll(test);|
  LFSR over GF(2^4)  given by CharPoly = y^4+y+Z(2^4)
  with feedback coeff =[ 0*Z(2), 0*Z(2), Z(2)^0, Z(2^4) ]
  with initial state  =[ 0*Z(2), Z(2^4), Z(2^2), Z(2)^0 ]
  with current state  =[ Z(2^2), Z(2^4)^2, Z(2^4)^2, Z(2^4)^11 ]
  after 5 steps
  with output from stage S_0
  !gapprompt@gap>| !gapinput@PrintAll(test, B);|
  LFSR over GF(2^4) defined by FieldPoly=x^4+x^3+Z(2)^0  given by CharPoly = y^4+y+Z(2^4)
  with feedback coeff =[ [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 0, 0, 0 ], [ 0, 1, 1, 0 ] ]
  with initial state  =[ [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 1 ], [ 1, 0, 0, 0 ] ]
  with current state  =[ [ 1, 1, 0, 1 ], [ 1, 0, 1, 1 ], [ 1, 0, 1, 1 ], [ 0, 1, 1, 1 ] ]
  after 5 steps
  with output from stage S_0
  
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{NLFSR specific funcionality}}\label{nlfsr}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X797E9B3381339AB2}{}
{
  

\subsection{\textcolor{Chapter }{ChooseField}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X824D14CF818525B2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ChooseField({\mdseries\slshape F})\index{ChooseField@\texttt{ChooseField}}
\label{ChooseField}
}\hfill{\scriptsize (function)}}\\


 Workaround for the \texttt{NLFSR} object definition: we need to fix the chosen underlying finite field and
prepare indeterminates in the chosen field. The indeterminates will be used
for the multivariable polynomial, which will define the \texttt{NLFSR} feedback. Current threshold is set by global \texttt{MaxNLFSRLen} = 100. 

 }

 

\subsection{\textcolor{Chapter }{NLFSR}}
\logpage{[ 3, 3, 2 ]}\nobreak
\hyperdef{L}{X7DDE3CAC7A9D2A55}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NLFSR({\mdseries\slshape K, clist, mlist, len[, tap]})\index{NLFSR@\texttt{NLFSR}}
\label{NLFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NLFSR({\mdseries\slshape K, fieldpol, clist, mlist, len[, tap]})\index{NLFSR@\texttt{NLFSR}}
\label{NLFSR}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 An empty \texttt{NLFSR} with components \texttt{init}, \texttt{state} and \texttt{numsteps} 



 Different ways to create an \texttt{NLFSR} oblject, main difference is in creation of the underlying finite field. 

 NOTE: before creating the \texttt{NLFSR}, we must always create the indeterminates to be used for the feedback using \texttt{ChooseField} function call!!! please see example below 

 

 Inputs: 
\begin{itemize}
\item  \mbox{\texttt{\mdseries\slshape F}} - the underlying finite field (either an extension field or a prime field)
\item  \mbox{\texttt{\mdseries\slshape fieldpol}} - defifning polynomial of the extension field (must be irreducible) TO DO 
\item  \mbox{\texttt{\mdseries\slshape clist}} - list of coefficients for the monomials in \mbox{\texttt{\mdseries\slshape mlist}} 
\item  \mbox{\texttt{\mdseries\slshape mlist}} - list of monomials 
\item  \mbox{\texttt{\mdseries\slshape len}} - length of \texttt{NLFSR} 
\item  \mbox{\texttt{\mdseries\slshape tap}} - optional parameter: the output tap (must be a positive integer or a list of
positive integers) and will be changed to the default S{\textunderscore}0 if
the specified integer is out of \texttt{NLFSR}range.
\end{itemize}
 NOTE: \mbox{\texttt{\mdseries\slshape clist}} and \mbox{\texttt{\mdseries\slshape mlist}} must be of same length, all elements in \mbox{\texttt{\mdseries\slshape clist}} must belong to the underlying field. Monomials in \mbox{\texttt{\mdseries\slshape mlist}} must not include any indeterminates that are out of range specified by \mbox{\texttt{\mdseries\slshape len}}: stages of \texttt{NLFSR} are represented by indeterminants and the feedback is not allowed to use a
stage that doesnt exist. A second constraint on \mbox{\texttt{\mdseries\slshape mlist}} requires that it must contain at least one monomial of degree $>$ 1, otherwise we must create an \texttt{LFSR}. 

 Compoents: 
\begin{itemize}
\item  \texttt{init} - \mbox{\texttt{\mdseries\slshape FFE}} vector of length n=deg(charpol), storing the initial state of the \texttt{NLFSR}, with indeces from n-1, ..., 0
\item  \texttt{state} - \mbox{\texttt{\mdseries\slshape FFE}} vector of length n=deg(charpol), storing the current state of the \texttt{NLFSR}, with indeces from n-1, ..., 0
\item  \texttt{numsteps} - the number of steps performed thus far (initialized to -1 when created, set
to 0 when loaded using \texttt{LoadFSR} (\ref{LoadFSR}) and incremented by 1 with each step (using \texttt{StepFSR} (\ref{StepFSR}))) 
\end{itemize}
 Attributes \texttt{FieldPoly} (\ref{FieldPoly}), \texttt{UnderlyingFied} (\ref{UnderlyingFied}), \texttt{MultivarPoly}, \texttt{FeedbackVec} (\ref{FeedbackVec}), \texttt{IndetList} (\ref{IndetList}), \texttt{Length} (\ref{Length}) and \texttt{OutputTap} (\ref{OutputTap}) and the property \texttt{IsNonLinearFeedback} are set during the construction of an \texttt{NLFSR}. 

 If there is something wrong with the arguments (e.g. attempting to create an
extension field using a reducible poynomial), an error message appears and the
function returns \texttt{fail}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@ F := GF(2);;  clist := [One(F), One(F)];; mlist := [x_0*x_1, x_2];;|
  Error, Variable: 'x_0' must have a value
  not in any function at line 2 of *stdin*
  !gapprompt@gap>| !gapinput@ test := NLFSR(F, clist, mlist, 3);|
  Error, Variable: 'mlist' must have a value
  not in any function at line 3 of *stdin*
  !gapprompt@gap>| !gapinput@ChooseField(F);|
  You can now create an NLFSR with up to 100 stages
  with up to  100 nonzero terms
  !gapprompt@gap>| !gapinput@mlist := [x_0*x_1, x_2];;                                           |
  !gapprompt@gap>| !gapinput@ test := NLFSR(F, clist, mlist, 3);|
  < empty NLFSR of length 3,
   given by MultivarPoly = x_0*x_1+x_2> 
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsNonLinearFeedback}}
\logpage{[ 3, 3, 3 ]}\nobreak
\hyperdef{L}{X7E493B9784FCFF58}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsNonLinearFeedback({\mdseries\slshape nlfsr})\index{IsNonLinearFeedback@\texttt{IsNonLinearFeedback}}
\label{IsNonLinearFeedback}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsNLFSR({\mdseries\slshape nlfsr})\index{IsNLFSR@\texttt{IsNLFSR}}
\label{IsNLFSR}
}\hfill{\scriptsize (filter)}}\\


 For the multivariate polynomial given by \mbox{\texttt{\mdseries\slshape clist}} and \mbox{\texttt{\mdseries\slshape mlist}}, DegreeOfPolynomial greter than 1 sets \texttt{IsNonLinearFeedback} to \emph{true}. otherwise it prints out a warning that you need to use the \texttt{LFSR} constructor instead. 

 Filter \texttt{IsNLFSR} is defined as and-filter of \texttt{IsFSR} and \texttt{IsNonLinearFeedback}. 

 NOTE: at the same time \texttt{IsLinearFeedback} is set to \emph{false} (for coding purposes). }

 

\subsection{\textcolor{Chapter }{MultivarPoly}}
\logpage{[ 3, 3, 4 ]}\nobreak
\hyperdef{L}{X7C6FCBDC82C3734E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MultivarPoly({\mdseries\slshape nlfsr})\index{MultivarPoly@\texttt{MultivarPoly}}
\label{MultivarPoly}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IndetList({\mdseries\slshape nlfsr})\index{IndetList@\texttt{IndetList}}
\label{IndetList}
}\hfill{\scriptsize (attribute)}}\\


 \texttt{MultivarPoly} holds the multivariate function defining the feedback of the \texttt{NLFSR}. \texttt{IndetList} holds all the indeterminates that are present in \texttt{MultivarPoly} and \texttt{FeedbackVec} holds only the nonzero coefficients (as opposed to the \texttt{LFSR}, where this field holds coefficients for all stages of the \texttt{FSR}). The feedback element is computed from \texttt{MultivarPoly}, \texttt{IndetList} and \texttt{state}, and not from \texttt{FeedbackVec}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@MultivarPoly(test); IndetList(test);|
  x_0*x_1+x_2
  [ 0, 1, 2 ]
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ViewObj}}
\logpage{[ 3, 3, 5 ]}\nobreak
\hyperdef{L}{X815BF22186FD43C9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ViewObj({\mdseries\slshape nlfsr})\index{ViewObj@\texttt{ViewObj}}
\label{ViewObj}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrintObj({\mdseries\slshape nlfsr[, B]})\index{PrintObj@\texttt{PrintObj}}
\label{PrintObj}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrintAll({\mdseries\slshape nlfsr[, B]})\index{PrintAll@\texttt{PrintAll}}
\label{PrintAll}
}\hfill{\scriptsize (method)}}\\


 Different detail on \mbox{\texttt{\mdseries\slshape nlfsr}} created by \texttt{NLFSR} (\ref{NLFSR}): 
\begin{itemize}
\item  \texttt{Display/View}: show the \texttt{MultivarPoly} and wheter or not the \mbox{\texttt{\mdseries\slshape nlfsr}} is empty
\item  \texttt{Print}: same as \texttt{Display/View} if \mbox{\texttt{\mdseries\slshape nlfsr}} is empty, otherwise it also shows the values of the three components \texttt{init}, \texttt{state} and \texttt{numsteps}
\item  \texttt{PrintAll}: same as \texttt{Print} if \mbox{\texttt{\mdseries\slshape nlfsr}} is empty, otherwise it also shows the values of the three components \texttt{init}, \texttt{state} and \texttt{numsteps} with additional information about the underlying field and the tap positions
\end{itemize}
 Both \texttt{Print} and \texttt{PrintAll} can be used with optional parameter basis \mbox{\texttt{\mdseries\slshape B}} for desiered output format. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  
  !gapprompt@gap>| !gapinput@Print(test);                                 |
  < empty NLFSR of length 3,
   given by MultivarPoly = x_0*x_1+x_2> 
  !gapprompt@gap>| !gapinput@PrintAll(test, Basis(UnderlyingField(test)));|
  < empty NLFSR of length 3,
   given by MultivarPoly = x_0*x_1+x_2> with feedback coeff =[ [ 1 ], [ 1 ] ]
  with initial state  =[ [ 0 ], [ 0 ], [ 0 ] ]
  with current state  =[ [ 0 ], [ 0 ], [ 0 ] ]
  after initialization 
  with output from stage S_0
  
\end{Verbatim}
 }

 }

 }

 
\chapter{\textcolor{Chapter }{misc - helper functions}}\label{misc}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X82DB6D4585397594}{}
{
  
\section{\textcolor{Chapter }{misc - helper functions}}\label{misc}
\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X82DB6D4585397594}{}
{
  

\subsection{\textcolor{Chapter }{MonomialsOverField (for an NLFSR)}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X7CF7FC2182FEA652}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MonomialsOverField({\mdseries\slshape F, poly})\index{MonomialsOverField@\texttt{MonomialsOverField}!for an NLFSR}
\label{MonomialsOverField:for an NLFSR}
}\hfill{\scriptsize (method)}}\\


 MonomialsOverField reduces takes a monomial or a list of monomials, and
reduces all the exponents modulo (Size(\mbox{\texttt{\mdseries\slshape F}})-1) for all extension fields and prime fields except for \mbox{\texttt{\mdseries\slshape F}}=$\mathcal(F)_2$. For $\mathcal(F)_2$ all the exponents are set to 1. }

 

\subsection{\textcolor{Chapter }{DegreeOfPolynomial (DegreeOfPolynomial)}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X85A860DA845F6090}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DegreeOfPolynomial({\mdseries\slshape F, poly})\index{DegreeOfPolynomial@\texttt{DegreeOfPolynomial}!DegreeOfPolynomial}
\label{DegreeOfPolynomial:DegreeOfPolynomial}
}\hfill{\scriptsize (method)}}\\


 \texttt{DegreeOfPolynomial} as follows for both monomial of form $p = \prod x_i^{e_i}$ and polynomial of form $P = \sum c_j\cdotp_j$ where $p_j = \prod_{i}x_i^{e_i}$ DegreeOfPolynomial for a monomial: $= \sum e_i$, where $i$ runs through all indeterminates present in this monomial DegreeOfPolynomial
for a polynomial: $= \max (DegreeOfPolynomial(p_j))$ , where $\max$ runs through all monomials $p_j$ present in this polynomial so an actual extra funstion called DegreeOfMonomial
is not needed }

 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{manual}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
